import { Inject, Injectable, InjectionToken, Injector, NgModule } from '@angular/core';
import { APP_BASE_HREF } from '@angular/common';
import { REQUEST, RESPONSE } from '@nguniversal/express-engine/tokens';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @param {?} obj
 * @return {?}
 */
function isBlank(obj) {
    return obj === undefined || obj === null;
}
/**
 * @param {?} obj
 * @return {?}
 */
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
/**
 * @param {?} obj
 * @return {?}
 */
function isString(obj) {
    return typeof obj === 'string';
}
/**
 * @param {?} oldOptions
 * @param {?=} newOptions
 * @return {?}
 */
function mergeOptions(oldOptions, newOptions) {
    if (!newOptions) {
        return oldOptions;
    }
    return {
        path: isPresent(newOptions.path) ? newOptions.path : oldOptions.path,
        domain: isPresent(newOptions.domain) ? newOptions.domain : oldOptions.domain,
        expires: isPresent(newOptions.expires) ? newOptions.expires : oldOptions.expires,
        secure: isPresent(newOptions.secure) ? newOptions.secure : oldOptions.secure,
        httpOnly: isPresent(newOptions.httpOnly) ? newOptions.httpOnly : oldOptions.httpOnly,
        storeUnencoded: isPresent(newOptions.storeUnencoded) ? newOptions.storeUnencoded : oldOptions.storeUnencoded,
    };
}
/**
 * @param {?} str
 * @return {?}
 */
function safeDecodeURIComponent(str) {
    try {
        return decodeURIComponent(str);
    }
    catch (e) {
        return str;
    }
}
/**
 * @param {?} str
 * @return {?}
 */
function safeJsonParse(str) {
    try {
        return JSON.parse(str);
    }
    catch (e) {
        return str;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
const COOKIE_OPTIONS = new InjectionToken('COOKIE_OPTIONS');
class CookieOptionsProvider {
    /**
     * @param {?=} options
     * @param {?=} _injector
     */
    constructor(options = {}, _injector) {
        this._injector = _injector;
        this.defaultOptions = {
            path: this._injector.get(APP_BASE_HREF, '/'),
            domain: null,
            expires: null,
            secure: false,
            httpOnly: false
        };
        this._options = mergeOptions(this.defaultOptions, options);
    }
    /**
     * @return {?}
     */
    get options() {
        return this._options;
    }
}
CookieOptionsProvider.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CookieOptionsProvider.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [COOKIE_OPTIONS,] }] },
    { type: Injector }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class CookieService {
    /**
     * @param {?} _optionsProvider
     */
    constructor(_optionsProvider) {
        this._optionsProvider = _optionsProvider;
        this.options = this._optionsProvider.options;
    }
    /**
     * @return {?}
     */
    get cookieString() {
        return document.cookie || '';
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set cookieString(val) {
        document.cookie = val;
    }
    /**
     * \@name CookieService#get
     *
     * \@description
     * Returns the value of given cookie key.
     *
     * @param {?} key Id to use for lookup.
     * @return {?} Raw cookie value.
     */
    get(key) {
        return ((/** @type {?} */ (this._cookieReader())))[key];
    }
    /**
     * \@name CookieService#getObject
     *
     * \@description
     * Returns the deserialized value of given cookie key.
     *
     * @param {?} key Id to use for lookup.
     * @return {?} Deserialized cookie value.
     */
    getObject(key) {
        /** @type {?} */
        const value = this.get(key);
        return value ? safeJsonParse(value) : value;
    }
    /**
     * \@name CookieService#getAll
     *
     * \@description
     * Returns a key value object with all the cookies.
     *
     * @return {?} All cookies
     */
    getAll() {
        return (/** @type {?} */ (this._cookieReader()));
    }
    /**
     * \@name CookieService#put
     *
     * \@description
     * Sets a value for given cookie key.
     *
     * @param {?} key Id for the `value`.
     * @param {?} value Raw value to be stored.
     * @param {?=} options (Optional) Options object.
     * @return {?}
     */
    put(key, value, options) {
        this._cookieWriter()(key, value, options);
    }
    /**
     * \@name CookieService#putObject
     *
     * \@description
     * Serializes and sets a value for given cookie key.
     *
     * @param {?} key Id for the `value`.
     * @param {?} value Value to be stored.
     * @param {?=} options (Optional) Options object.
     * @return {?}
     */
    putObject(key, value, options) {
        this.put(key, JSON.stringify(value), options);
    }
    /**
     * \@name CookieService#remove
     *
     * \@description
     * Remove given cookie.
     *
     * @param {?} key Id of the key-value pair to delete.
     * @param {?=} options (Optional) Options object.
     * @return {?}
     */
    remove(key, options) {
        this._cookieWriter()(key, undefined, options);
    }
    /**
     * \@name CookieService#removeAll
     *
     * \@description
     * Remove all cookies.
     * @param {?=} options
     * @return {?}
     */
    removeAll(options) {
        /** @type {?} */
        const cookies = this.getAll();
        Object.keys(cookies).forEach(key => {
            this.remove(key, options);
        });
    }
    /**
     * @return {?}
     */
    _cookieReader() {
        /** @type {?} */
        let lastCookies = {};
        /** @type {?} */
        let lastCookieString = '';
        /** @type {?} */
        let cookieArray;
        /** @type {?} */
        let cookie;
        /** @type {?} */
        let i;
        /** @type {?} */
        let index;
        /** @type {?} */
        let name;
        /** @type {?} */
        const currentCookieString = this.cookieString;
        if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
                cookie = cookieArray[i];
                index = cookie.indexOf('=');
                if (index > 0) { // ignore nameless cookies
                    name = safeDecodeURIComponent(cookie.substring(0, index));
                    // the first value that is seen for a cookie is the most
                    // specific one.  values for the same cookie name that
                    // follow are for less specific paths.
                    if (isBlank(((/** @type {?} */ (lastCookies)))[name])) {
                        ((/** @type {?} */ (lastCookies)))[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                    }
                }
            }
        }
        return lastCookies;
    }
    /**
     * @return {?}
     */
    _cookieWriter() {
        /** @type {?} */
        const that = this;
        return function (name, value, options) {
            that.cookieString = that._buildCookieString(name, value, options);
        };
    }
    /**
     * @param {?} name
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    _buildCookieString(name, value, options) {
        /** @type {?} */
        const opts = mergeOptions(this.options, options);
        /** @type {?} */
        let expires = opts.expires;
        if (isBlank(value)) {
            expires = 'Thu, 01 Jan 1970 00:00:00 GMT';
            value = '';
        }
        if (isString(expires)) {
            expires = new Date(expires);
        }
        /** @type {?} */
        const cookieValue = opts.storeUnencoded ? value : encodeURIComponent(value);
        /** @type {?} */
        let str = encodeURIComponent(name) + '=' + cookieValue;
        str += opts.path ? ';path=' + opts.path : '';
        str += opts.domain ? ';domain=' + opts.domain : '';
        str += expires ? ';expires=' + expires.toUTCString() : '';
        str += opts.secure ? ';secure' : '';
        str += opts.httpOnly ? '; HttpOnly' : '';
        // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:
        // - 300 cookies
        // - 20 cookies per unique domain
        // - 4096 bytes per cookie
        /** @type {?} */
        const cookieLength = str.length + 1;
        if (cookieLength > 4096) {
            console.log(`Cookie \'${name}\' possibly not set or overflowed because it was too large (${cookieLength} > 4096 bytes)!`);
        }
        return str;
    }
}
CookieService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CookieService.ctorParameters = () => [
    { type: CookieOptionsProvider }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class CookieBackendService extends CookieService {
    /**
     * @param {?} request
     * @param {?} response
     * @param {?} _optionsProvider
     */
    constructor(request, response, _optionsProvider) {
        super(_optionsProvider);
        this.request = request;
        this.response = response;
    }
    /**
     * @return {?}
     */
    get cookieString() {
        return this.request.cookie || '';
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set cookieString(val) {
        this.request.cookie = val;
        this.response.cookie = val;
    }
}
CookieBackendService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CookieBackendService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [REQUEST,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [RESPONSE,] }] },
    { type: CookieOptionsProvider }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @param {?} cookieOptionsProvider
 * @return {?}
 */
function cookieServiceFactory(cookieOptionsProvider) {
    return new CookieService(cookieOptionsProvider);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class CookieModule {
    /**
     * Use this method in your root module to provide the CookieService
     * @param {?=} options
     * @return {?}
     */
    static forRoot(options = {}) {
        return {
            ngModule: CookieModule,
            providers: [
                { provide: COOKIE_OPTIONS, useValue: options },
                { provide: CookieService, useFactory: cookieServiceFactory, deps: [CookieOptionsProvider] }
            ]
        };
    }
    /**
     * Use this method in your other (non root) modules to import the directive/pipe
     * @param {?=} options
     * @return {?}
     */
    static forChild(options = {}) {
        return {
            ngModule: CookieModule,
            providers: [
                { provide: COOKIE_OPTIONS, useValue: options },
                { provide: CookieService, useFactory: cookieServiceFactory, deps: [CookieOptionsProvider] }
            ]
        };
    }
}
CookieModule.decorators = [
    { type: NgModule, args: [{
                providers: [CookieOptionsProvider]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

export { CookieService, CookieBackendService, COOKIE_OPTIONS, CookieOptionsProvider, cookieServiceFactory, isBlank, isPresent, isString, mergeOptions, safeDecodeURIComponent, safeJsonParse, CookieModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNvb2tpZS5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vbmd4LWNvb2tpZS9saWIvdXRpbHMudHMiLCJuZzovL25neC1jb29raWUvbGliL2Nvb2tpZS1vcHRpb25zLXByb3ZpZGVyLnRzIiwibmc6Ly9uZ3gtY29va2llL2xpYi9jb29raWUuc2VydmljZS50cyIsIm5nOi8vbmd4LWNvb2tpZS9saWIvY29va2llLWJhY2tlbmQuc2VydmljZS50cyIsIm5nOi8vbmd4LWNvb2tpZS9saWIvY29va2llLmZhY3RvcnkudHMiLCJuZzovL25neC1jb29raWUvbGliL2Nvb2tpZS5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29va2llT3B0aW9ucyB9IGZyb20gJy4vY29va2llLW9wdGlvbnMubW9kZWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNCbGFuayhvYmo6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQcmVzZW50KG9iajogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyhvYmo6IGFueSk6IG9iaiBpcyBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZU9wdGlvbnMob2xkT3B0aW9uczogQ29va2llT3B0aW9ucywgbmV3T3B0aW9ucz86IENvb2tpZU9wdGlvbnMpOiBDb29raWVPcHRpb25zIHtcbiAgaWYgKCFuZXdPcHRpb25zKSB7XG4gICAgcmV0dXJuIG9sZE9wdGlvbnM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBpc1ByZXNlbnQobmV3T3B0aW9ucy5wYXRoKSA/IG5ld09wdGlvbnMucGF0aCA6IG9sZE9wdGlvbnMucGF0aCxcbiAgICBkb21haW46IGlzUHJlc2VudChuZXdPcHRpb25zLmRvbWFpbikgPyBuZXdPcHRpb25zLmRvbWFpbiA6IG9sZE9wdGlvbnMuZG9tYWluLFxuICAgIGV4cGlyZXM6IGlzUHJlc2VudChuZXdPcHRpb25zLmV4cGlyZXMpID8gbmV3T3B0aW9ucy5leHBpcmVzIDogb2xkT3B0aW9ucy5leHBpcmVzLFxuICAgIHNlY3VyZTogaXNQcmVzZW50KG5ld09wdGlvbnMuc2VjdXJlKSA/IG5ld09wdGlvbnMuc2VjdXJlIDogb2xkT3B0aW9ucy5zZWN1cmUsXG4gICAgaHR0cE9ubHk6IGlzUHJlc2VudChuZXdPcHRpb25zLmh0dHBPbmx5KSA/IG5ld09wdGlvbnMuaHR0cE9ubHkgOiBvbGRPcHRpb25zLmh0dHBPbmx5LFxuICAgIHN0b3JlVW5lbmNvZGVkOiBpc1ByZXNlbnQobmV3T3B0aW9ucy5zdG9yZVVuZW5jb2RlZCkgPyBuZXdPcHRpb25zLnN0b3JlVW5lbmNvZGVkIDogb2xkT3B0aW9ucy5zdG9yZVVuZW5jb2RlZCxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhZmVEZWNvZGVVUklDb21wb25lbnQoc3RyOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYWZlSnNvblBhcnNlKHN0cjogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cbiIsImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBUFBfQkFTRV9IUkVGIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgQ29va2llT3B0aW9ucyB9IGZyb20gJy4vY29va2llLW9wdGlvbnMubW9kZWwnO1xuaW1wb3J0IHsgbWVyZ2VPcHRpb25zIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBjb25zdCBDT09LSUVfT1BUSU9OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxDb29raWVPcHRpb25zPignQ09PS0lFX09QVElPTlMnKTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvb2tpZU9wdGlvbnNQcm92aWRlciB7XG5cbiAgcHJpdmF0ZSBkZWZhdWx0T3B0aW9uczogQ29va2llT3B0aW9ucztcbiAgcHJpdmF0ZSBfb3B0aW9uczogQ29va2llT3B0aW9ucztcblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KENPT0tJRV9PUFRJT05TKSBvcHRpb25zOiBDb29raWVPcHRpb25zID0ge30sXG4gICAgICAgICAgICAgIHByaXZhdGUgX2luamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBwYXRoOiB0aGlzLl9pbmplY3Rvci5nZXQoQVBQX0JBU0VfSFJFRiwgJy8nKSxcbiAgICAgIGRvbWFpbjogbnVsbCxcbiAgICAgIGV4cGlyZXM6IG51bGwsXG4gICAgICBzZWN1cmU6IGZhbHNlLFxuICAgICAgaHR0cE9ubHk6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLl9vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMuZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKTogQ29va2llT3B0aW9ucyB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ29va2llT3B0aW9uc1Byb3ZpZGVyIH0gZnJvbSAnLi9jb29raWUtb3B0aW9ucy1wcm92aWRlcic7XG5pbXBvcnQgeyBDb29raWVPcHRpb25zIH0gZnJvbSAnLi9jb29raWUtb3B0aW9ucy5tb2RlbCc7XG5pbXBvcnQgeyBpc0JsYW5rLCBpc1N0cmluZywgbWVyZ2VPcHRpb25zLCBzYWZlRGVjb2RlVVJJQ29tcG9uZW50LCBzYWZlSnNvblBhcnNlIH0gZnJvbSAnLi91dGlscyc7XG5cbmRlY2xhcmUgaW50ZXJmYWNlIERvY3VtZW50IHtcbiAgY29va2llOiBzdHJpbmc7XG59XG5kZWNsYXJlIGNvbnN0IGRvY3VtZW50OiBEb2N1bWVudDtcblxuZXhwb3J0IGludGVyZmFjZSBJQ29va2llU2VydmljZSB7XG4gIGdldChrZXk6IHN0cmluZyk6IHN0cmluZztcbiAgZ2V0T2JqZWN0KGtleTogc3RyaW5nKTogT2JqZWN0O1xuICBnZXRBbGwoKTogT2JqZWN0O1xuICBwdXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIG9wdGlvbnM/OiBDb29raWVPcHRpb25zKTogdm9pZDtcbiAgcHV0T2JqZWN0KGtleTogc3RyaW5nLCB2YWx1ZTogT2JqZWN0LCBvcHRpb25zPzogQ29va2llT3B0aW9ucyk6IHZvaWQ7XG4gIHJlbW92ZShrZXk6IHN0cmluZywgb3B0aW9ucz86IENvb2tpZU9wdGlvbnMpOiB2b2lkO1xuICByZW1vdmVBbGwob3B0aW9ucz86IENvb2tpZU9wdGlvbnMpOiB2b2lkO1xufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29va2llU2VydmljZSBpbXBsZW1lbnRzIElDb29raWVTZXJ2aWNlIHtcblxuICBwcm90ZWN0ZWQgb3B0aW9uczogQ29va2llT3B0aW9ucztcblxuICBwcm90ZWN0ZWQgZ2V0IGNvb2tpZVN0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiBkb2N1bWVudC5jb29raWUgfHwgJyc7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0IGNvb2tpZVN0cmluZyh2YWw6IHN0cmluZykge1xuICAgIGRvY3VtZW50LmNvb2tpZSA9IHZhbDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX29wdGlvbnNQcm92aWRlcjogQ29va2llT3B0aW9uc1Byb3ZpZGVyKSB7XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5fb3B0aW9uc1Byb3ZpZGVyLm9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgQ29va2llU2VydmljZSNnZXRcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGdpdmVuIGNvb2tpZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgSWQgdG8gdXNlIGZvciBsb29rdXAuXG4gICAqIEByZXR1cm5zIFJhdyBjb29raWUgdmFsdWUuXG4gICAqL1xuICBnZXQoa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiAoPGFueT50aGlzLl9jb29raWVSZWFkZXIoKSlba2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBDb29raWVTZXJ2aWNlI2dldE9iamVjdFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmV0dXJucyB0aGUgZGVzZXJpYWxpemVkIHZhbHVlIG9mIGdpdmVuIGNvb2tpZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgSWQgdG8gdXNlIGZvciBsb29rdXAuXG4gICAqIEByZXR1cm5zIERlc2VyaWFsaXplZCBjb29raWUgdmFsdWUuXG4gICAqL1xuICBnZXRPYmplY3Qoa2V5OiBzdHJpbmcpOiBPYmplY3Qge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoa2V5KTtcbiAgICByZXR1cm4gdmFsdWUgPyBzYWZlSnNvblBhcnNlKHZhbHVlKSA6IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIENvb2tpZVNlcnZpY2UjZ2V0QWxsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXR1cm5zIGEga2V5IHZhbHVlIG9iamVjdCB3aXRoIGFsbCB0aGUgY29va2llcy5cbiAgICpcbiAgICogQHJldHVybnMgQWxsIGNvb2tpZXNcbiAgICovXG4gIGdldEFsbCgpOiBPYmplY3Qge1xuICAgIHJldHVybiA8YW55PnRoaXMuX2Nvb2tpZVJlYWRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIENvb2tpZVNlcnZpY2UjcHV0XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXRzIGEgdmFsdWUgZm9yIGdpdmVuIGNvb2tpZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgSWQgZm9yIHRoZSBgdmFsdWVgLlxuICAgKiBAcGFyYW0gdmFsdWUgUmF3IHZhbHVlIHRvIGJlIHN0b3JlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgKE9wdGlvbmFsKSBPcHRpb25zIG9iamVjdC5cbiAgICovXG4gIHB1dChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZywgb3B0aW9ucz86IENvb2tpZU9wdGlvbnMpIHtcbiAgICB0aGlzLl9jb29raWVXcml0ZXIoKShrZXksIHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBDb29raWVTZXJ2aWNlI3B1dE9iamVjdFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogU2VyaWFsaXplcyBhbmQgc2V0cyBhIHZhbHVlIGZvciBnaXZlbiBjb29raWUga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IElkIGZvciB0aGUgYHZhbHVlYC5cbiAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGJlIHN0b3JlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgKE9wdGlvbmFsKSBPcHRpb25zIG9iamVjdC5cbiAgICovXG4gIHB1dE9iamVjdChrZXk6IHN0cmluZywgdmFsdWU6IE9iamVjdCwgb3B0aW9ucz86IENvb2tpZU9wdGlvbnMpIHtcbiAgICB0aGlzLnB1dChrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgQ29va2llU2VydmljZSNyZW1vdmVcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJlbW92ZSBnaXZlbiBjb29raWUuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgSWQgb2YgdGhlIGtleS12YWx1ZSBwYWlyIHRvIGRlbGV0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgKE9wdGlvbmFsKSBPcHRpb25zIG9iamVjdC5cbiAgICovXG4gIHJlbW92ZShrZXk6IHN0cmluZywgb3B0aW9ucz86IENvb2tpZU9wdGlvbnMpOiB2b2lkIHtcbiAgICB0aGlzLl9jb29raWVXcml0ZXIoKShrZXksIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgQ29va2llU2VydmljZSNyZW1vdmVBbGxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJlbW92ZSBhbGwgY29va2llcy5cbiAgICovXG4gIHJlbW92ZUFsbChvcHRpb25zPzogQ29va2llT3B0aW9ucyk6IHZvaWQge1xuICAgIGNvbnN0IGNvb2tpZXMgPSB0aGlzLmdldEFsbCgpO1xuICAgIE9iamVjdC5rZXlzKGNvb2tpZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlKGtleSwgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIF9jb29raWVSZWFkZXIoKTogT2JqZWN0IHtcbiAgICBsZXQgbGFzdENvb2tpZXMgPSB7fTtcbiAgICBsZXQgbGFzdENvb2tpZVN0cmluZyA9ICcnO1xuICAgIGxldCBjb29raWVBcnJheTogc3RyaW5nW10sIGNvb2tpZTogc3RyaW5nLCBpOiBudW1iZXIsIGluZGV4OiBudW1iZXIsIG5hbWU6IHN0cmluZztcbiAgICBjb25zdCBjdXJyZW50Q29va2llU3RyaW5nID0gdGhpcy5jb29raWVTdHJpbmc7XG4gICAgaWYgKGN1cnJlbnRDb29raWVTdHJpbmcgIT09IGxhc3RDb29raWVTdHJpbmcpIHtcbiAgICAgIGxhc3RDb29raWVTdHJpbmcgPSBjdXJyZW50Q29va2llU3RyaW5nO1xuICAgICAgY29va2llQXJyYXkgPSBsYXN0Q29va2llU3RyaW5nLnNwbGl0KCc7ICcpO1xuICAgICAgbGFzdENvb2tpZXMgPSB7fTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb29raWVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb29raWUgPSBjb29raWVBcnJheVtpXTtcbiAgICAgICAgaW5kZXggPSBjb29raWUuaW5kZXhPZignPScpO1xuICAgICAgICBpZiAoaW5kZXggPiAwKSB7ICAvLyBpZ25vcmUgbmFtZWxlc3MgY29va2llc1xuICAgICAgICAgIG5hbWUgPSBzYWZlRGVjb2RlVVJJQ29tcG9uZW50KGNvb2tpZS5zdWJzdHJpbmcoMCwgaW5kZXgpKTtcbiAgICAgICAgICAvLyB0aGUgZmlyc3QgdmFsdWUgdGhhdCBpcyBzZWVuIGZvciBhIGNvb2tpZSBpcyB0aGUgbW9zdFxuICAgICAgICAgIC8vIHNwZWNpZmljIG9uZS4gIHZhbHVlcyBmb3IgdGhlIHNhbWUgY29va2llIG5hbWUgdGhhdFxuICAgICAgICAgIC8vIGZvbGxvdyBhcmUgZm9yIGxlc3Mgc3BlY2lmaWMgcGF0aHMuXG4gICAgICAgICAgaWYgKGlzQmxhbmsoKDxhbnk+bGFzdENvb2tpZXMpW25hbWVdKSkge1xuICAgICAgICAgICAgKDxhbnk+bGFzdENvb2tpZXMpW25hbWVdID0gc2FmZURlY29kZVVSSUNvbXBvbmVudChjb29raWUuc3Vic3RyaW5nKGluZGV4ICsgMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGFzdENvb2tpZXM7XG4gIH1cblxuICBwcml2YXRlIF9jb29raWVXcml0ZXIoKSB7XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgb3B0aW9ucz86IENvb2tpZU9wdGlvbnMpIHtcbiAgICAgIHRoYXQuY29va2llU3RyaW5nID0gdGhhdC5fYnVpbGRDb29raWVTdHJpbmcobmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICBwcml2YXRlIF9idWlsZENvb2tpZVN0cmluZyhuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIG9wdGlvbnM/OiBDb29raWVPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCBvcHRzOiBDb29raWVPcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgbGV0IGV4cGlyZXM6IGFueSA9IG9wdHMuZXhwaXJlcztcbiAgICBpZiAoaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgIGV4cGlyZXMgPSAnVGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBHTVQnO1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKGV4cGlyZXMpKSB7XG4gICAgICBleHBpcmVzID0gbmV3IERhdGUoZXhwaXJlcyk7XG4gICAgfVxuICAgIGNvbnN0IGNvb2tpZVZhbHVlID0gb3B0cy5zdG9yZVVuZW5jb2RlZCA/IHZhbHVlIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICBsZXQgc3RyID0gZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpICsgJz0nICsgY29va2llVmFsdWU7XG4gICAgc3RyICs9IG9wdHMucGF0aCA/ICc7cGF0aD0nICsgb3B0cy5wYXRoIDogJyc7XG4gICAgc3RyICs9IG9wdHMuZG9tYWluID8gJztkb21haW49JyArIG9wdHMuZG9tYWluIDogJyc7XG4gICAgc3RyICs9IGV4cGlyZXMgPyAnO2V4cGlyZXM9JyArIGV4cGlyZXMudG9VVENTdHJpbmcoKSA6ICcnO1xuICAgIHN0ciArPSBvcHRzLnNlY3VyZSA/ICc7c2VjdXJlJyA6ICcnO1xuICAgIHN0ciArPSBvcHRzLmh0dHBPbmx5ID8gJzsgSHR0cE9ubHknIDogJyc7XG5cbiAgICAvLyBwZXIgaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMjEwOS50eHQgYnJvd3NlciBtdXN0IGFsbG93IGF0IG1pbmltdW06XG4gICAgLy8gLSAzMDAgY29va2llc1xuICAgIC8vIC0gMjAgY29va2llcyBwZXIgdW5pcXVlIGRvbWFpblxuICAgIC8vIC0gNDA5NiBieXRlcyBwZXIgY29va2llXG4gICAgY29uc3QgY29va2llTGVuZ3RoID0gc3RyLmxlbmd0aCArIDE7XG4gICAgaWYgKGNvb2tpZUxlbmd0aCA+IDQwOTYpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBDb29raWUgXFwnJHtuYW1lfVxcJyBwb3NzaWJseSBub3Qgc2V0IG9yIG92ZXJmbG93ZWQgYmVjYXVzZSBpdCB3YXMgdG9vIGxhcmdlICgke2Nvb2tpZUxlbmd0aH0gPiA0MDk2IGJ5dGVzKSFgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSRVFVRVNULCBSRVNQT05TRSB9IGZyb20gJ0BuZ3VuaXZlcnNhbC9leHByZXNzLWVuZ2luZS90b2tlbnMnO1xuXG5pbXBvcnQgeyBDb29raWVTZXJ2aWNlIH0gZnJvbSAnLi9jb29raWUuc2VydmljZSc7XG5pbXBvcnQgeyBDb29raWVPcHRpb25zUHJvdmlkZXIgfSBmcm9tICcuL2Nvb2tpZS1vcHRpb25zLXByb3ZpZGVyJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvb2tpZUJhY2tlbmRTZXJ2aWNlIGV4dGVuZHMgQ29va2llU2VydmljZSB7XG5cbiAgY29uc3RydWN0b3IoQEluamVjdChSRVFVRVNUKSBwcml2YXRlIHJlcXVlc3Q6IGFueSxcbiAgICAgICAgICAgICAgQEluamVjdChSRVNQT05TRSkgcHJpdmF0ZSByZXNwb25zZTogYW55LFxuICAgICAgICAgICAgICBfb3B0aW9uc1Byb3ZpZGVyOiBDb29raWVPcHRpb25zUHJvdmlkZXIpIHtcbiAgICBzdXBlcihfb3B0aW9uc1Byb3ZpZGVyKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgY29va2llU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdC5jb29raWUgfHwgJyc7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0IGNvb2tpZVN0cmluZyh2YWw6IHN0cmluZykge1xuICAgIHRoaXMucmVxdWVzdC5jb29raWUgPSB2YWw7XG4gICAgdGhpcy5yZXNwb25zZS5jb29raWUgPSB2YWw7XG4gIH1cbn1cbiIsImltcG9ydCB7IENvb2tpZVNlcnZpY2UgfSBmcm9tICcuL2Nvb2tpZS5zZXJ2aWNlJztcbmltcG9ydCB7IENvb2tpZU9wdGlvbnNQcm92aWRlciB9IGZyb20gJy4vY29va2llLW9wdGlvbnMtcHJvdmlkZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gY29va2llU2VydmljZUZhY3RvcnkoY29va2llT3B0aW9uc1Byb3ZpZGVyOiBDb29raWVPcHRpb25zUHJvdmlkZXIpOiBDb29raWVTZXJ2aWNlIHtcbiAgcmV0dXJuIG5ldyBDb29raWVTZXJ2aWNlKGNvb2tpZU9wdGlvbnNQcm92aWRlcik7XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSwgTW9kdWxlV2l0aFByb3ZpZGVycyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDb29raWVPcHRpb25zUHJvdmlkZXIsIENPT0tJRV9PUFRJT05TIH0gZnJvbSAnLi9jb29raWUtb3B0aW9ucy1wcm92aWRlcic7XG5pbXBvcnQgeyBDb29raWVTZXJ2aWNlIH0gZnJvbSAnLi9jb29raWUuc2VydmljZSc7XG5pbXBvcnQgeyBDb29raWVPcHRpb25zIH0gZnJvbSAnLi9jb29raWUtb3B0aW9ucy5tb2RlbCc7XG5pbXBvcnQgeyBjb29raWVTZXJ2aWNlRmFjdG9yeSB9IGZyb20gJy4vY29va2llLmZhY3RvcnknO1xuXG5ATmdNb2R1bGUoe1xuICBwcm92aWRlcnM6IFtDb29raWVPcHRpb25zUHJvdmlkZXJdXG59KVxuZXhwb3J0IGNsYXNzIENvb2tpZU1vZHVsZSB7XG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgaW4geW91ciByb290IG1vZHVsZSB0byBwcm92aWRlIHRoZSBDb29raWVTZXJ2aWNlXG4gICAqL1xuICBzdGF0aWMgZm9yUm9vdChvcHRpb25zOiBDb29raWVPcHRpb25zID0ge30pOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmdNb2R1bGU6IENvb2tpZU1vZHVsZSxcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7cHJvdmlkZTogQ09PS0lFX09QVElPTlMsIHVzZVZhbHVlOiBvcHRpb25zfSxcbiAgICAgICAge3Byb3ZpZGU6IENvb2tpZVNlcnZpY2UsIHVzZUZhY3Rvcnk6IGNvb2tpZVNlcnZpY2VGYWN0b3J5LCBkZXBzOiBbQ29va2llT3B0aW9uc1Byb3ZpZGVyXX1cbiAgICAgIF1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCBpbiB5b3VyIG90aGVyIChub24gcm9vdCkgbW9kdWxlcyB0byBpbXBvcnQgdGhlIGRpcmVjdGl2ZS9waXBlXG4gICAqL1xuICBzdGF0aWMgZm9yQ2hpbGQob3B0aW9uczogQ29va2llT3B0aW9ucyA9IHt9KTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5nTW9kdWxlOiBDb29raWVNb2R1bGUsXG4gICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge3Byb3ZpZGU6IENPT0tJRV9PUFRJT05TLCB1c2VWYWx1ZTogb3B0aW9uc30sXG4gICAgICAgIHtwcm92aWRlOiBDb29raWVTZXJ2aWNlLCB1c2VGYWN0b3J5OiBjb29raWVTZXJ2aWNlRmFjdG9yeSwgZGVwczogW0Nvb2tpZU9wdGlvbnNQcm92aWRlcl19XG4gICAgICBdXG4gICAgfTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUVBLFNBQWdCLE9BQU8sQ0FBQyxHQUFRO0lBQzlCLE9BQU8sR0FBRyxLQUFLLFNBQVMsSUFBSSxHQUFHLEtBQUssSUFBSSxDQUFDO0NBQzFDOzs7OztBQUVELFNBQWdCLFNBQVMsQ0FBQyxHQUFRO0lBQ2hDLE9BQU8sR0FBRyxLQUFLLFNBQVMsSUFBSSxHQUFHLEtBQUssSUFBSSxDQUFDO0NBQzFDOzs7OztBQUVELFNBQWdCLFFBQVEsQ0FB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